'use client'

import { useState, useCallback, useEffect } from 'react'
import type {
  ComponentVersion,
  MigrationGuide,
  CompatibilityCheckResponse,
  MigrationPathResponse,
  VersionStatistics,
} from '../types'

interface UseVersionSwitchingOptions {
  componentId: number
  apiBaseUrl?: string
  onVersionChanged?: (version: string) => void
  onError?: (error: Error) => void
}

interface UseVersionSwitchingReturn {
  versions: ComponentVersion[]
  currentVersion: string
  isLoading: boolean
  error: string | null
  isSwitching: boolean
  listVersions: () => Promise<void>
  getVersion: (versionStr: string) => Promise<ComponentVersion | null>
  switchVersion: (toVersion: string) => Promise<void>
  checkCompatibility: (
    fromVersion: string,
    toVersion: string
  ) => Promise<CompatibilityCheckResponse | null>
  validateMigrationPath: (
    fromVersion: string,
    toVersion: string
  ) => Promise<MigrationPathResponse | null>
  getVersionStatistics: () => Promise<VersionStatistics | null>
  getLatestVersion: () => Promise<ComponentVersion | null>
}

/**
 * useVersionSwitching: Custom hook for managing component version switching
 *
 * Features:
 * - Fetch and cache component versions
 * - Switch between versions with validation
 * - Check compatibility between versions
 * - Handle migration paths
 * - Track version statistics
 * - Error handling and loading states
 *
 * @example
 * const {
 *   versions,
 *   currentVersion,
 *   switchVersion,
 *   checkCompatibility,
 * } = useVersionSwitching({ componentId: 123 })
 */
export function useVersionSwitching({
  componentId,
  apiBaseUrl = '/api/v1',
  onVersionChanged,
  onError,
}: UseVersionSwitchingOptions): UseVersionSwitchingReturn {
  const [versions, setVersions] = useState<ComponentVersion[]>([])
  const [currentVersion, setCurrentVersion] = useState<string>('')
  const [isLoading, setIsLoading] = useState(false)
  const [isSwitching, setIsSwitching] = useState(false)
  const [error, setError] = useState<string | null>(null)

  // Helper to make API calls
  const apiCall = useCallback(
    async <T,>(path: string, options: RequestInit = {}): Promise<T | null> => {
      try {
        const response = await fetch(`${apiBaseUrl}${path}`, {
          headers: {
            'Content-Type': 'application/json',
            ...options.headers,
          },
          ...options,
        })

        if (!response.ok) {
          throw new Error(`API Error: ${response.status}`)
        }

        const data = await response.json()
        return data.data || data
      } catch (err) {
        const error = err instanceof Error ? err : new Error(String(err))
        setError(error.message)
        onError?.(error)
        return null
      }
    },
    [apiBaseUrl, onError]
  )

  // List all versions for component
  const listVersions = useCallback(async () => {
    setIsLoading(true)
    setError(null)

    try {
      const response = await fetch(
        `${apiBaseUrl}/admin/components/${componentId}/versions`
      )

      if (!response.ok) {
        throw new Error('Failed to fetch versions')
      }

      const data = await response.json()
      if (data.data?.versions) {
        setVersions(data.data.versions)
        // Set current version to latest
        const latest = data.data.versions.find((v: ComponentVersion) => v.is_latest)
        if (latest) {
          setCurrentVersion(latest.version)
        }
      }
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err))
      setError(error.message)
      onError?.(error)
    } finally {
      setIsLoading(false)
    }
  }, [componentId, apiBaseUrl, onError])

  // Get specific version
  const getVersion = useCallback(
    async (versionStr: string): Promise<ComponentVersion | null> => {
      const cached = versions.find(v => v.version === versionStr)
      if (cached) {
        return cached
      }

      return apiCall<ComponentVersion>(
        `/admin/components/${componentId}/versions/${versionStr}`
      )
    },
    [componentId, versions, apiCall]
  )

  // Switch version with validation
  const switchVersion = useCallback(
    async (toVersion: string) => {
      setIsSwitching(true)
      setError(null)

      try {
        // Validate target version exists
        const targetVersion = await getVersion(toVersion)
        if (!targetVersion) {
          throw new Error(`Version ${toVersion} not found`)
        }

        // Check compatibility if switching from current version
        if (currentVersion && currentVersion !== toVersion) {
          const compat = await checkCompatibility(currentVersion, toVersion)
          if (!compat?.compatible) {
            console.warn(
              `Version ${toVersion} may have compatibility issues with ${currentVersion}`
            )
          }
        }

        // Make API call to switch version
        const response = await fetch(
          `${apiBaseUrl}/admin/components/${componentId}/versions/${toVersion}/switch`,
          {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({ version: toVersion }),
          }
        )

        if (!response.ok) {
          throw new Error('Failed to switch version')
        }

        setCurrentVersion(toVersion)
        onVersionChanged?.(toVersion)
      } catch (err) {
        const error = err instanceof Error ? err : new Error(String(err))
        setError(error.message)
        onError?.(error)
        throw error
      } finally {
        setIsSwitching(false)
      }
    },
    [componentId, apiBaseUrl, currentVersion, getVersion, onVersionChanged, onError]
  )

  // Check compatibility between versions
  const checkCompatibility = useCallback(
    async (
      fromVersion: string,
      toVersion: string
    ): Promise<CompatibilityCheckResponse | null> => {
      return apiCall<CompatibilityCheckResponse>(
        `/admin/components/${componentId}/versions/check-compatibility?from=${fromVersion}&to=${toVersion}`
      )
    },
    [componentId, apiCall]
  )

  // Validate migration path exists
  const validateMigrationPath = useCallback(
    async (
      fromVersion: string,
      toVersion: string
    ): Promise<MigrationPathResponse | null> => {
      return apiCall<MigrationPathResponse>(
        `/admin/components/${componentId}/versions/validate-migration?from=${fromVersion}&to=${toVersion}`
      )
    },
    [componentId, apiCall]
  )

  // Get version statistics
  const getVersionStatistics = useCallback(
    async (): Promise<VersionStatistics | null> => {
      return apiCall<VersionStatistics>(
        `/admin/components/${componentId}/versions/statistics`
      )
    },
    [componentId, apiCall]
  )

  // Get latest version
  const getLatestVersion = useCallback(async (): Promise<ComponentVersion | null> => {
    return apiCall<ComponentVersion>(
      `/admin/components/${componentId}/versions/latest`
    )
  }, [componentId, apiCall])

  // Load versions on mount
  useEffect(() => {
    listVersions()
  }, [listVersions])

  return {
    versions,
    currentVersion,
    isLoading,
    error,
    isSwitching,
    listVersions,
    getVersion,
    switchVersion,
    checkCompatibility,
    validateMigrationPath,
    getVersionStatistics,
    getLatestVersion,
  }
}

export default useVersionSwitching
