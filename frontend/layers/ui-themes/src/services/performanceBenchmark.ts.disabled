/**
 * Performance Benchmarking Suite
 * Measures Web Vitals and generates performance reports
 */

export interface PerformanceMetric {
  name: string
  value: number
  unit: string
  timestamp: number
  rating: 'good' | 'needs_improvement' | 'poor'
}

export interface WebVitals {
  lcp?: PerformanceMetric // Largest Contentful Paint
  fid?: PerformanceMetric // First Input Delay
  cls?: PerformanceMetric // Cumulative Layout Shift
  fcp?: PerformanceMetric // First Contentful Paint
  ttfb?: PerformanceMetric // Time to First Byte
}

export interface PerformanceBenchmark {
  url: string
  timestamp: number
  webVitals: WebVitals
  resourceMetrics: Record<string, PerformanceMetric>
  customMetrics: Record<string, PerformanceMetric>
  summary: {
    overallScore: number
    passedThresholds: number
    totalThresholds: number
  }
}

export interface ThresholdConfig {
  metric: string
  goodThreshold: number
  needsImprovementThreshold: number
  unit: string
}

class PerformanceBenchmark {
  private metrics: Map<string, PerformanceMetric> = new Map()
  private observer: PerformanceObserver | null = null
  private startTime: number = 0
  private thresholds: Map<string, ThresholdConfig> = new Map()
  private history: PerformanceBenchmark[] = []

  constructor() {
    this.initializeThresholds()
    this.startTime = performance.now()
  }

  /**
   * Initialize performance thresholds
   */
  private initializeThresholds() {
    const defaultThresholds: ThresholdConfig[] = [
      { metric: 'lcp', goodThreshold: 2500, needsImprovementThreshold: 4000, unit: 'ms' },
      { metric: 'fid', goodThreshold: 100, needsImprovementThreshold: 300, unit: 'ms' },
      { metric: 'cls', goodThreshold: 0.1, needsImprovementThreshold: 0.25, unit: '' },
      { metric: 'fcp', goodThreshold: 1800, needsImprovementThreshold: 3000, unit: 'ms' },
      { metric: 'ttfb', goodThreshold: 600, needsImprovementThreshold: 1800, unit: 'ms' },
    ]

    defaultThresholds.forEach((t) => {
      this.thresholds.set(t.metric, t)
    })
  }

  /**
   * Start monitoring performance
   */
  public startMonitoring() {
    if ('PerformanceObserver' in window) {
      try {
        // Observe all performance entries
        const observer = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries()
          entries.forEach((entry) => {
            this.processEntry(entry)
          })
        })

        observer.observe({
          entryTypes: ['paint', 'largest-contentful-paint', 'first-input', 'layout-shift', 'resource'],
        })

        this.observer = observer
      } catch (e) {
        console.error('[PerformanceBenchmark] Failed to initialize observer:', e)
      }
    }

    // Measure Web Vitals
    this.measureWebVitals()
  }

  /**
   * Measure Core Web Vitals
   */
  private measureWebVitals() {
    // LCP - Largest Contentful Paint
    if ('PerformanceObserver' in window) {
      try {
        const lcpObserver = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries()
          const lastEntry = entries[entries.length - 1]
          this.recordMetric(
            'lcp',
            lastEntry.renderTime || lastEntry.loadTime,
            'ms'
          )
        })
        lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] })
      } catch (e) {
        console.error('[PerformanceBenchmark] LCP measurement failed:', e)
      }
    }

    // FCP - First Contentful Paint
    const fcpEntries = performance.getEntriesByName('first-contentful-paint')
    if (fcpEntries.length > 0) {
      this.recordMetric('fcp', fcpEntries[0].startTime, 'ms')
    }

    // TTFB - Time to First Byte
    const navigationTiming = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming
    if (navigationTiming) {
      const ttfb = navigationTiming.responseStart - navigationTiming.requestStart
      this.recordMetric('ttfb', ttfb, 'ms')
    }
  }

  /**
   * Process performance entry
   */
  private processEntry(entry: PerformanceEntry) {
    if (entry.entryType === 'layout-shift') {
      const layoutShiftEntry = entry as LayoutShift
      this.recordMetric('cls', layoutShiftEntry.value, '')
    }

    if (entry.entryType === 'first-input') {
      const firstInputEntry = entry as PerformanceEventTiming
      this.recordMetric('fid', firstInputEntry.processingDuration, 'ms')
    }

    if (entry.entryType === 'resource') {
      const resourceEntry = entry as PerformanceResourceTiming
      const duration = resourceEntry.duration
      const resourceName = resourceEntry.name.split('/').pop() || 'unknown'

      this.recordMetric(`resource_${resourceName}`, duration, 'ms')
    }
  }

  /**
   * Record a custom metric
   */
  public recordCustomMetric(name: string, value: number, unit: string = 'ms') {
    this.recordMetric(`custom_${name}`, value, unit)
  }

  /**
   * Record a metric with automatic rating
   */
  private recordMetric(name: string, value: number, unit: string) {
    const threshold = this.thresholds.get(name)
    let rating: 'good' | 'needs_improvement' | 'poor' = 'poor'

    if (threshold) {
      if (value <= threshold.goodThreshold) {
        rating = 'good'
      } else if (value <= threshold.needsImprovementThreshold) {
        rating = 'needs_improvement'
      }
    }

    const metric: PerformanceMetric = {
      name,
      value,
      unit,
      timestamp: Date.now(),
      rating,
    }

    this.metrics.set(name, metric)
    console.log(`[PerformanceBenchmark] ${name}: ${value}${unit} (${rating})`)
  }

  /**
   * Generate performance report
   */
  public generateReport(): PerformanceBenchmark {
    const webVitals: WebVitals = {}
    const resourceMetrics: Record<string, PerformanceMetric> = {}
    const customMetrics: Record<string, PerformanceMetric> = {}
    let passedThresholds = 0
    let totalThresholds = 0

    this.metrics.forEach((metric, key) => {
      if (key.startsWith('custom_')) {
        customMetrics[key.replace('custom_', '')] = metric
      } else if (key.startsWith('resource_')) {
        resourceMetrics[key.replace('resource_', '')] = metric
      } else {
        webVitals[key as keyof WebVitals] = metric
        totalThresholds++
        if (metric.rating === 'good') {
          passedThresholds++
        }
      }
    })

    const overallScore = totalThresholds > 0 ? (passedThresholds / totalThresholds) * 100 : 0

    const report: PerformanceBenchmark = {
      url: window.location.href,
      timestamp: Date.now(),
      webVitals,
      resourceMetrics,
      customMetrics,
      summary: {
        overallScore,
        passedThresholds,
        totalThresholds,
      },
    }

    this.history.push(report)

    return report
  }

  /**
   * Get performance history
   */
  public getHistory(limit: number = 50): PerformanceBenchmark[] {
    return this.history.slice(-limit)
  }

  /**
   * Compare current metrics with baseline
   */
  public compareWithBaseline(baseline: PerformanceBenchmark): Record<string, number> {
    const comparison: Record<string, number> = {}

    this.metrics.forEach((metric, key) => {
      const baselineMetric = baseline.webVitals[key as keyof WebVitals] ||
        baseline.resourceMetrics[key] ||
        baseline.customMetrics[key]

      if (baselineMetric) {
        const difference = metric.value - baselineMetric.value
        const percentChange = (difference / baselineMetric.value) * 100
        comparison[key] = percentChange
      }
    })

    return comparison
  }

  /**
   * Stop monitoring and cleanup
   */
  public stopMonitoring() {
    if (this.observer) {
      this.observer.disconnect()
      this.observer = null
    }
  }

  /**
   * Export data as JSON
   */
  public exportAsJSON(): string {
    return JSON.stringify(this.generateReport(), null, 2)
  }

  /**
   * Export data as CSV
   */
  public exportAsCSV(): string {
    const report = this.generateReport()
    const rows: string[] = [
      'Metric,Value,Unit,Rating,Timestamp',
    ]

    // Add Web Vitals
    Object.entries(report.webVitals).forEach(([name, metric]) => {
      if (metric) {
        rows.push(
          `${name},${metric.value},${metric.unit},${metric.rating},${metric.timestamp}`
        )
      }
    })

    // Add custom metrics
    Object.entries(report.customMetrics).forEach(([name, metric]) => {
      rows.push(
        `${name},${metric.value},${metric.unit},${metric.rating},${metric.timestamp}`
      )
    })

    return rows.join('\n')
  }
}

// Export singleton
let benchmarkInstance: PerformanceBenchmark

export function initializeBenchmark(): PerformanceBenchmark {
  benchmarkInstance = new PerformanceBenchmark()
  benchmarkInstance.startMonitoring()
  return benchmarkInstance
}

export function getBenchmark(): PerformanceBenchmark {
  if (!benchmarkInstance) {
    benchmarkInstance = new PerformanceBenchmark()
  }
  return benchmarkInstance
}

export default PerformanceBenchmark
